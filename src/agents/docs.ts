import { BaseAgent, AgentInput, AgentOutput } from './base';
import { eventBus, EventType } from '../core/eventBus';
import { memoryStore } from '../core/memoryStore';

/**
 * DocsAgent - Generates comprehensive documentation
 */
export class DocsAgent extends BaseAgent {
  constructor(systemPrompt?: string) {
    super('DocsAgent', systemPrompt || 'You are a technical writer...');
    this.setupEventListeners();
  }

  /**
   * Execute documentation generation
   */
  async execute(input: AgentInput): Promise<AgentOutput> {
    const project = memoryStore.getCurrentProject();
    if (!project) {
      return {
        success: false,
        error: new Error('No active project'),
      };
    }

    try {
      // Get all artifacts
      const requirements = memoryStore.getArtifact(project.id, 'requirements');
      const architecture = memoryStore.getArtifact(project.id, 'architecture');

      // Generate README
      const readme = await this.generateREADME(project, requirements, architecture);

      // Generate API documentation
      const apiDocs = await this.generateAPIDocs(project, architecture);

      // Generate architecture documentation
      const archDocs = await this.generateArchitectureDocs(project, architecture);

      // Generate deployment guide
      const deploymentGuide = await this.generateDeploymentGuide(project);

      // Generate contributing guide
      const contributingGuide = await this.generateContributingGuide(project);

      const docsArtifacts = {
        readme,
        apiDocs,
        architectureDocs: archDocs,
        deploymentGuide,
        contributingGuide,
        changelog: this.generateChangelog(project),
      };

      // Store artifacts
      memoryStore.storeArtifact(project.id, 'documentation', docsArtifacts);

      return {
        success: true,
        result: docsArtifacts,
        artifacts: docsArtifacts,
        message: 'Documentation generation completed successfully',
      };
    } catch (error) {
      return {
        success: false,
        error: error as Error,
      };
    }
  }

  /**
   * Generate README
   */
  private async generateREADME(project: any, requirements: any, architecture: any): Promise<any> {
    const techStack = project.techStack;
    const techStackList = [
      ...(techStack.backend || []),
      ...(techStack.frontend || []),
      ...(techStack.database || []),
    ].join(', ');

    return {
      name: 'README.md',
      content: `
# ${project.purposeName} Project

> Generated by Auto Cursor - Autonomous AI Development System

## ğŸ“‹ Overview

This project implements a ${project.purposeName.toLowerCase()} using modern best practices and cutting-edge technologies.

## ğŸš€ Tech Stack

${techStackList}

## ğŸ“¦ Prerequisites

- Node.js 18+
- Docker & Docker Compose
- PostgreSQL 15+ (if applicable)

## ğŸ› ï¸ Installation

\`\`\`bash
# Clone the repository
git clone <repository-url>
cd ${project.id}

# Install dependencies
npm install

# Setup environment variables
cp .env.example .env

# Start services with Docker Compose
docker-compose up -d
\`\`\`

## ğŸƒ Running the Application

### Development Mode

\`\`\`bash
npm run dev
\`\`\`

### Production Mode

\`\`\`bash
npm run build
npm start
\`\`\`

## ğŸ§ª Testing

\`\`\`bash
# Run all tests
npm test

# Run with coverage
npm test -- --coverage

# Run E2E tests
npm run test:e2e
\`\`\`

## ğŸ“š Documentation

- [Architecture](docs/ARCHITECTURE.md)
- [API Documentation](docs/API.md)
- [Deployment Guide](docs/DEPLOYMENT.md)
- [Contributing Guide](CONTRIBUTING.md)

## ğŸ—ï¸ Project Structure

\`\`\`
.
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ utils/
â”‚   â””â”€â”€ types/
â”œâ”€â”€ tests/
â”œâ”€â”€ docs/
â”œâ”€â”€ docker/
â””â”€â”€ k8s/
\`\`\`

## ğŸ¤ Contributing

Please read [CONTRIBUTING.md](CONTRIBUTING.md) for details on our code of conduct and the process for submitting pull requests.

## ğŸ“ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## ğŸ™ Acknowledgments

Built with Auto Cursor - AI-powered autonomous development system.
`,
    };
  }

  /**
   * Generate API documentation
   */
  private async generateAPIDocs(project: any, architecture: any): Promise<any> {
    const apiContracts = architecture?.apiContracts || [];

    let endpointsDoc = '';
    apiContracts.forEach((endpoint: any) => {
      endpointsDoc += `
### ${endpoint.method} ${endpoint.path}

**Description:** ${endpoint.description}

**Request:**
\`\`\`json
{
  // Request body
}
\`\`\`

**Response:**
\`\`\`json
{
  "success": true,
  "data": {}
}
\`\`\`

---
`;
    });

    return {
      name: 'docs/API.md',
      content: `
# API Documentation

## Base URL

\`\`\`
http://localhost:8080/api
\`\`\`

## Authentication

All protected endpoints require a JWT token in the Authorization header:

\`\`\`
Authorization: Bearer <token>
\`\`\`

## Endpoints

${endpointsDoc}

## Error Responses

All endpoints may return the following error responses:

- **400 Bad Request:** Invalid request parameters
- **401 Unauthorized:** Missing or invalid authentication token
- **404 Not Found:** Resource not found
- **500 Internal Server Error:** Server error
`,
    };
  }

  /**
   * Generate architecture documentation
   */
  private async generateArchitectureDocs(project: any, architecture: any): Promise<any> {
    return {
      name: 'docs/ARCHITECTURE.md',
      content: `
# Architecture Documentation

## Overview

${architecture?.overview?.description || 'System architecture overview'}

## Architecture Pattern

**Pattern:** ${architecture?.overview?.pattern || 'Layered Architecture'}

## Components

${(architecture?.components || [])
  .map((comp: any) => `### ${comp.name}\n\n${comp.responsibility}`)
  .join('\n\n')}

## Data Models

${(architecture?.dataModels || [])
  .map((model: any) => `### ${model.name}\n\nFields: ${model.fields.join(', ')}`)
  .join('\n\n')}

## Design Patterns

${(architecture?.designPatterns || []).map((pattern: string) => `- ${pattern}`).join('\n')}

## Technology Decisions

${(architecture?.technologyDecisions || [])
  .map((decision: any) => `### ${decision.decision}\n\n${decision.rationale}`)
  .join('\n\n')}

## Scalability Considerations

- Horizontal scaling through container orchestration
- Database connection pooling
- Caching strategy with Redis
- Load balancing

## Security Considerations

- Authentication and authorization
- Input validation
- SQL injection prevention
- HTTPS/TLS encryption
`,
    };
  }

  /**
   * Generate deployment guide
   */
  private async generateDeploymentGuide(project: any): Promise<any> {
    return {
      name: 'docs/DEPLOYMENT.md',
      content: `
# Deployment Guide

## Prerequisites

- Docker & Docker Compose
- Kubernetes cluster (for production)
- kubectl configured
- CI/CD pipeline setup

## Local Deployment

\`\`\`bash
# Build Docker image
docker build -t app:latest .

# Start with Docker Compose
docker-compose up -d
\`\`\`

## Production Deployment

### Kubernetes

\`\`\`bash
# Apply Kubernetes manifests
kubectl apply -f k8s/

# Check deployment status
kubectl get pods
kubectl get svc
kubectl get ingress
\`\`\`

### Environment Variables

Required environment variables:

- \`NODE_ENV\`: Environment (production/staging/development)
- \`DB_HOST\`: Database host
- \`DB_PASSWORD\`: Database password
- \`REDIS_HOST\`: Redis host
- \`JWT_SECRET\`: JWT signing secret

## Monitoring

- Prometheus metrics: \`http://localhost:9090\`
- Grafana dashboard: \`http://localhost:3000\`

## Rollback

\`\`\`bash
# Rollback to previous version
kubectl rollout undo deployment/app
\`\`\`

## Health Checks

- Liveness probe: \`/health\`
- Readiness probe: \`/ready\`
`,
    };
  }

  /**
   * Generate contributing guide
   */
  private async generateContributingGuide(project: any): Promise<any> {
    return {
      name: 'CONTRIBUTING.md',
      content: `
# Contributing Guide

## Getting Started

1. Fork the repository
2. Clone your fork
3. Create a feature branch
4. Make your changes
5. Run tests
6. Submit a pull request

## Development Workflow

\`\`\`bash
# Create feature branch
git checkout -b feature/my-feature

# Make changes and commit
git add .
git commit -m "feat: add new feature"

# Push to your fork
git push origin feature/my-feature
\`\`\`

## Commit Convention

We follow [Conventional Commits](https://www.conventionalcommits.org/):

- \`feat:\` New feature
- \`fix:\` Bug fix
- \`docs:\` Documentation changes
- \`style:\` Code style changes
- \`refactor:\` Code refactoring
- \`test:\` Test changes
- \`chore:\` Build/tooling changes

## Code Style

- Run \`npm run lint\` before committing
- Follow existing code style
- Add tests for new features
- Update documentation as needed

## Pull Request Process

1. Update README.md with details of changes
2. Ensure all tests pass
3. Update documentation
4. Request review from maintainers

## Code Review

All submissions require review. We use GitHub pull requests for this purpose.
`,
    };
  }

  /**
   * Generate changelog
   */
  private generateChangelog(project: any): any {
    return {
      name: 'CHANGELOG.md',
      content: `
# Changelog

All notable changes to this project will be documented in this file.

## [1.0.0] - ${new Date().toISOString().split('T')[0]}

### Added
- Initial project setup
- Core functionality implementation
- Comprehensive test suite
- Documentation
- CI/CD pipeline
- Docker and Kubernetes configuration

### Generated by Auto Cursor
This project was autonomously created by the Auto Cursor AI system.
`,
    };
  }

  /**
   * Setup event listeners
   */
  private setupEventListeners(): void {
    eventBus.on(EventType.PHASE_DOCUMENTATION_START, async () => {
      const result = await this.execute({});

      eventBus.emit(EventType.PHASE_DOCUMENTATION_COMPLETE, {
        timestamp: Date.now(),
        phase: 'documentation',
        result: result.result,
        artifacts: result.artifacts,
        source: 'DocsAgent',
      });
    });
  }
}

